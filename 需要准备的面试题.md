## Java基础

### Vector,ArrayList, LinkedList的区别是什么？

答：

1. Vector、ArrayList都是以类似数组的形式存储在内存中，LinkedList则以链表的形式进行存储。

2. List中的元素有序、允许有重复的元素，Set中的元素无序、不允许有重复元素。

3. Vector线程同步，ArrayList、LinkedList线程不同步。

4. LinkedList适合指定位置插入、删除操作，不适合查找；ArrayList、Vector适合查找，不适合指定位置的插入、删除操作。

5. ArrayList在元素填满容器时会自动扩充容器大小的50%，而Vector则是100%，因此ArrayList更节省空间。

### HashTable, HashMap，TreeMap区别？

答：

1. HashTable线程同步，HashMap非线程同步。

2. HashTable不允许<键,值>有空值，HashMap允许<键,值>有空值。

3. HashTable使用Enumeration，HashMap使用Iterator。

4. HashTable中hash数组的默认大小是11，增加方式的old*2+1，HashMap中hash数组的默认大小是16，增长方式一定是2的指数倍。

5. TreeMap能够把它保存的记录根据键排序，默认是按升序排序。

### HashMap的数据结构

jdk1.8之前list + 链表
jdk1.8之后list + 链表（当链表长度到8时，转化为红黑树）

### HashMap的扩容因子  
 
默认0.75，也就是会浪费1/4的空间，达到扩容因子时，会将list扩容一倍，0.75 是时间与空间一个平衡值；
 
### 多线程修改HashMap 

多线程同时写入，同时执行扩容操作，多线程扩容可能死锁、丢数据；可以对HashMap 加入同步锁Collections.synchronizedMap(hashMap)，但是效率很低，因为该锁是互斥锁，同一时刻只能有一个线程执行读写操作，这时候应该使用ConcurrentHashMap

### LinkedHashMap

[Java LinkedHashMap工作原理及实现](http://www.importnew.com/18706.html)

[Java集合框架：LinkedHashMap](http://www.importnew.com/18726.html)

**注意：在使用Iterator遍历的时候，LinkedHashMap会产生`java.util.ConcurrentModificationException`。**

> 扩展HashMap增加双向链表的实现，号称是最占内存的数据结构。支持iterator()时按Entry的插入顺序来排序(但是更新不算， 如果设置accessOrder属性为true，则所有读写访问都算)。实现上是在Entry上再增加属性before/after指针，插入时把自己加到Header Entry的前面去。如果所有读写访问都要排序，还要把前后Entry的before/after拼接起来以在链表中删除掉自己。

### 说说你知道的几个Java集合类：list、set、queue、map实现类

### 描述一下ArrayList和LinkedList各自实现和区别

[Java基础篇(四):ArrayList和LinkedList内部实现、区别、使用场景](https://www.jianshu.com/p/5b3aa50aa388)

### Java中的队列都有哪些，有什么区别

1. ArrayDeque, （数组双端队列） 
2. PriorityQueue, （优先级队列） 
3. ConcurrentLinkedQueue, （基于链表的并发队列） 
4. DelayQueue, （延期阻塞队列）（阻塞队列实现了BlockingQueue接口） 
5. ArrayBlockingQueue, （基于数组的并发阻塞队列） 
6. LinkedBlockingQueue, （基于链表的FIFO阻塞队列） 
7. LinkedBlockingDeque, （基于链表的FIFO双端阻塞队列） 
8. PriorityBlockingQueue, （带优先级的无界阻塞队列） 
9. SynchronousQueue （并发同步阻塞队列）

### 反射中，Class.forName和classloader的区别

[java反射中，Class.forName和classloader的区别(代码说话)](http://blog.csdn.net/qq_27093465/article/details/52262340)

### Java7、Java8的新特性

[java7,8的几个特性](http://blog.csdn.net/little_newbee/article/details/74963879)

### Java数组和链表两种结构的操作效率，在哪些情况下(从开头开始，从结尾开始，从中间开始)，哪些操作(插入，查找，删除)的效率高

### 讲讲IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞

[Java IO流详解（二）——IO流的框架体系](https://www.jianshu.com/p/80f8a74d4662)

### 讲讲NIO
[NIO技术概览](http://www.ideabuffer.cn/2017/08/13/NIO%E6%8A%80%E6%9C%AF%E6%A6%82%E8%A7%88/)
### 缓冲区

### 虚拟内存&&内存空间的映射

### 三个channel使用 ServerSocketChannel||SocketChannel||FileChannel

[Java NIO系列教程（八） SocketChannel](http://ifeve.com/socket-channel/)

[Java NIO系列教程（九） ServerSocketChannel](http://ifeve.com/server-socket-channel/)

[Java NIO系列教程（七） FileChannel](http://ifeve.com/file-channel/)

### String 编码UTF-8 和GBK的区别

* GBK编码：是指中国的中文字符，其实它包含了简体中文与繁体中文字符，另外还有一种字符“gb2312”，这种字符仅能存储简体中文字符。 
* UTF-8编码：它是一种全国家通过的一种编码，如果你的网站涉及到多个国家的语言，那么建议你选择UTF-8编码。 

GBK和UTF8有什么区别？ 

UTF8编码格式很强大，支持所有国家的语言，正是因为它的强大，才会导致它占用的空间大小要比GBK大，对于网站打开速度而言，也是有一定影响的。 
GBK编码格式，它的功能少，仅限于中文字符，当然它所占用的空间大小会随着它的功能而减少，打开网页的速度比较快。

### 什么时候使用字节流、什么时候使用字符流

[什么时候使用字节流、什么时候使用字符流，二者的区别](http://blog.csdn.net/wangyunpeng0319/article/details/72853592)

### 递归读取文件夹下的文件，代码怎么实现

```java
/** 
 * 递归读取文件夹下的 所有文件 
 * 
 * @param testFileDir 文件名或目录名 
 */  
private static void testLoopOutAllFileName(String testFileDir) {  
    if (testFileDir == null) {  
        //因为new File(null)会空指针异常,所以要判断下  
        return;  
    }  
    File[] testFile = new File(testFileDir).listFiles();  
    if (testFile == null) {  
        return;  
    }  
    for (File file : testFile) {  
        if (file.isFile()) {  
            System.out.println(file.getName());  
        } else if (file.isDirectory()) {  
            System.out.println("-------this is a directory, and its files are as follows:-------");  
            testLoopOutAllFileName(file.getPath());  
        } else {  
            System.out.println("文件读入有误！");  
        }  
    }  
} 
```

### Object.finalize

[深入分析Object.finalize方法的实现原理](https://www.jianshu.com/p/9d2788fffd5f)

## Java并发和并行

* 并发 : 是指两个或多个事件在同一时间间隔发生,在一台处理器上“同时”处理多个任务;
* 并行 : 是指两个或者多个事件在同一时刻发生,在多台处理器上同时处理多个任务。

### 怎么提高并发量，请列举你所知道的方案？

[高并发解决方案——提升高并发量服务器性能解决思路](http://blog.csdn.net/xy2953396112/article/details/62426117)

### 系统的用户量有多少？多用户并发访问时如何解决？

[大型网站是怎样解决多用户高并发访问的](http://blog.csdn.net/liangzi_lucky/article/details/52441368)

### 说说阻塞队列的实现：可以参考ArrayBlockingQueue的底层实现（锁和同步都行）

[Java阻塞队列ArrayBlockingQueue和LinkedBlockingQueue实现原理分析](http://blog.csdn.net/x_i_y_u_e/article/details/52513038)

### 进程通讯的方式：消息队列，共享内存，信号量，socket通讯等

[Linux进程间通信方式--信号，管道，消息队列，信号量，共享内存](http://blog.csdn.net/u010027547/article/details/49027457)

### 用过并发包的哪些类

### Excutors可以产生哪些线程池

### 为什么要用线程池

[为什么要使用线程池](http://blog.csdn.net/a497393102/article/details/8597819)

### 线程池的基础概念

core,maxPoolSize,keepalive

执行任务时
1. 如果线程池中线程数量 < core，新建一个线程执行任务；
2. 如果线程池中线程数量 >= core ,则将任务放入任务队列
3. 如果线程池中线程数量 >= core 且 < maxPoolSize，则创建新的线程；
4. 如果线程池中线程数量 > core ,当线程空闲时间超过了keepalive时，则会销毁线程；由此可见线程池的队列如果是无界队列，那么设置线程池最大数量是无效的；

### 自带线程池的各种坑

1. Executors.newFixedThreadPool(10);
固定大小的线程池：
它的实现new ThreadPoolExecutor(10, 10, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
初始化一个指定线程数的线程池，其中corePoolSize == maximumPoolSize，使用LinkedBlockingQuene作为阻塞队列，当线程池没有可执行任务时，也不会释放线程。
由于LinkedBlockingQuene的特性，这个队列是无界的，若消费不过来，会导致内存被任务队列占满，最终oom；

2. Executors.newCachedThreadPool();
缓存线程池：
它的实现new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue<Runnable>());
初始化一个可以缓存线程的线程池，默认缓存60s，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列；和newFixedThreadPool创建的线程池不同，newCachedThreadPool在没有任务执行时，当线程的空闲时间超过keepAliveTime，会自动释放线程资源，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销，因为线程池的最大值了Integer.MAX_VALUE，会导致无限创建线程；所以，使用该线程池时，一定要注意控制并发的任务数，否则创建大量的线程会导致严重的性能问题;

3. Executors.newSingleThreadExecutor()
单线程线程池：
同newFixedThreadPool线程池一样，队列用的是LinkedBlockingQueue无界队列，可以无限的往里面添加任务，直到内存溢出；

### volatile关键字的用法：使多线程中的变量可见

[Java并发编程：volatile关键字解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)

### 线程的几种状态

线程在一定条件下，状态会发生变化。线程一共有以下几种状态：
1. 新建状态(New)：新创建了一个线程对象。
2. 就绪状态(Runnable)：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权。即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。
3. 运行状态(Running)：就绪状态的线程获取了CPU，执行程序代码。
4. 阻塞状态(Blocked)：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。
阻塞的情况分三种：
    1. 等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，
    2. 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。
    3. 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
5. 死亡状态(Dead)：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

### 常用的线程池模式以及不同线程池的使用场景

[java线程池与五种常用线程池策略使用与解析](http://blog.csdn.net/u011479540/article/details/51867886)

### newFixedThreadPool此种线程池如果线程数达到最大值后会怎么办，底层原理。

### 多线程之间通信的同步问题，synchronized锁的是对象，衍伸出和synchronized相关很多的具体问题，例如同一个类不同方法都有synchronized锁，一个对象是否可以同时访问。或者一个类的static构造方法加上synchronized之后的锁的影响。

### 了解可重入锁的含义，以及ReentrantLock 和synchronized的区别

### 同步的数据结构，例如concurrentHashMap的源码理解以及内部实现原理，为什么他是同步的且效率高

### atomicinteger和Volatile等线程安全操作的关键字的理解和使用

### CAS和volatile关键字

通过volatile修饰的变量可以保证线程之间的可见性，但并不能保证字节码指令的原子执行，在多线程并发执行下，无法做到线程安全，得到正确的结果

1. 加锁(低效率)
2. cas

引用占小狼的简书：[面试必问的CAS，要多了解](https://www.jianshu.com/p/24ffe531e9ee)

### 线程间通信，wait和notify

[wait和notify的理解与使用](http://blog.csdn.net/jianiuqi/article/details/53448849)

### 定时线程的使用

### 场景：在一个主线程中，要求有大量(很多很多)子线程执行完之后，主线程才执行完成。多种方式，考虑效率。

[java线程池主线程等待子线程执行完成](http://blog.csdn.net/yaowj2/article/details/7431440)

### 进程和线程的区别

* 进程：
      
是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说进程是可以独立运行的一段程序(比如正在运行的某个java程序)。      
      
* 线程：

他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源(一个线程只能属于一个进程，而一个进程可以有多个线程)。

### 什么叫线程安全？举例说明

* java中的线程安全是什么：
      
就是线程同步的意思，就是当一个程序对一个线程安全的方法或者语句进行访问的时候，其他的不能再对他进行操作了，必须等到这次访问结束以后才能对这个线程安全的方法进行访问

* 什么叫线程安全：

如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，
就是线程安全的。

或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。

线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。

存在竞争的线程不安全，不存在竞争的线程就是安全的

### 并发、同步的接口或方法

[Java并发编程的类、接口和方法](http://blog.csdn.net/woshisap/article/details/43119569)

### HashMap 是否线程安全，为何不安全。 ConcurrentHashMap，线程安全，为何安全。底层实现是怎么样的。

[深入浅出ConcurrentHashMap1.8](https://www.jianshu.com/p/c0642afe03e0)

[谈谈ConcurrentHashMap1.7和1.8的不同实现](https://www.jianshu.com/p/e694f1e868ec)

[ConcurrentHashMap的红黑树实现分析](https://www.jianshu.com/p/23b84ba9a498)

[深入分析ConcurrentHashMap1.8的扩容实现](https://www.jianshu.com/p/f6730d5784ad)

[老生常谈，HashMap的死循环](https://www.jianshu.com/p/1e9cf0ac07f4)

### J.U.C下的常见类的使用。 ThreadPool的深入考察； BlockingQueue的使用。（take，poll的区别，put，offer的区别）；原子类的实现。

### volatile的理解

[java volatile关键字解惑](https://www.jianshu.com/p/195ae7c77afe)

[面试必问的volatile，你了解多少？](https://www.jianshu.com/p/506c1e38a922)

### Tomcat并发

[Tomcat的性能与最大并发配置](http://blog.csdn.net/xiangtianzaijie500/article/details/52768462)

### 有个每秒钟5k个请求，查询手机号所属地的笔试题(记得不完整，没列出)，如何设计算法?请求再多，比如5w，如何设计整个系统?

### 高并发情况下，我们系统是如何支撑大量的请求的

* 尽量使用缓存，包括用户缓存，信息缓存等，多花点内存来做缓存，可以大量减少与数据库的交互，提高性能。
* 用jprofiler等工具找出性能瓶颈，减少额外的开销。
* 优化数据库查询语句，减少直接使用hibernate等工具的直接生成语句（仅耗时较长的查询做优化）。
* 优化数据库结构，多做索引，提高查询效率。
* 统计的功能尽量做缓存，或按每天一统计或定时统计相关报表，避免需要时进行统计的功能。
* 能使用静态页面的地方尽量使用，减少容器的解析（尽量将动态内容生成静态html来显示）。
* 解决以上问题后，使用服务器集群来解决单台的瓶颈问题。

1. HTML静态化 
效率最高、消耗最小的就是纯静态化的html页面，所以尽可能使网站上的页面采用静态页面来实现，这个最简单的方法其实也是最有效的方法。但是对于大量内容并且频繁更新的网站，无法全部手动去挨个实现，于是出现了常见的信息发布系统CMS，像常访问的各个门户站点的新闻频道，甚至他们的其他频道，都是通过信息发布系统来管理和实现的，信息发布系统可以实现最简单的信息录入自动生成静态页面，还能具备频道管理、权限管理、自动抓取等功能，对于一个大型网站来说，拥有一套高效、可管理的CMS是必不可少的。 
2. 图片服务器分离 
对于Web服务器来说，不管是Apache、IIS还是其他容器，图片是最消耗资源的，于是有必要将图片与页面进行分离，这是基本上大型网站都会采用的策略，他们都有独立的图片服务器，甚至很多台图片服务器。这样的架构可以降低提供页面访问请求的服务器系统压力，并且可以保证系统不会因为图片问题而崩溃，在应用服务器和图片服务器上，可以进行不同的配置优化，比如apache在配置ContentType的时候可以尽量少支持，尽可能少的LoadModule，保证更高的系统消耗和执行效率。 这一实现起来是比较容易的一现，如果服务器集群操作起来更方便，如果是独立的服务器，新手可能出现上传图片只能在服务器本地的情况下，可以在令一台服务器设置的IIS采用网络路径来实现图片服务器，即不用改变程序，又能提高性能，但对于服务器本身的IO处理性能是没有任何的改变。
3. 数据库集群和库表散列 
大型网站都有复杂的应用，这些应用必须使用数据库，那么在面对大量访问的时候，数据库的瓶颈很快就能显现出来，这时一台数据库将很快无法满足应用，于是需要使用数据库集群或者库表散列。 
4. 缓存 
缓存一词搞技术的都接触过，很多地方用到缓存。网站架构和网站开发中的缓存也是非常重要。架构方面的缓存，对Apache比较熟悉的人都能知道Apache提供了自己的缓存模块，也可以使用外加的Squid模块进行缓存，这两种方式均可以有效的提高Apache的访问响应能力。 
网站程序开发方面的缓存，Linux上提供的Memory Cache是常用的缓存接口，可以在web开发中使用，比如用Java开发的时候就可以调用MemoryCache对一些数据进行缓存和通讯共享，一些大型社区使用了这样的架构。另外，在使用web语言开发的时候，各种语言基本都有自己的缓存模块和方法，PHP有Pear的Cache模块，Java就更多了，.net不是很熟悉，相信也肯定有。 
5. 镜像 
镜像是大型网站常采用的提高性能和数据安全性的方式，镜像的技术可以解决不同网络接入商和地域带来的用户访问速度差异，比如ChinaNet和EduNet之间的差异就促使了很多网站在教育网内搭建镜像站点，数据进行定时更新或者实时更新。在镜像的细节技术方面，这里不阐述太深，有很多专业的现成的解决架构和产品可选。也有廉价的通过软件实现的思路，比如Linux上的rsync等工具。 
6. 负载均衡 
负载均衡将是大型网站解决高负荷访问和大量并发请求采用的终极解决办法。 负载均衡技术发展了多年，有很多专业的服务提供商和产品可以选择。 

    硬件四层交换 

    第四层交换使用第三层和第四层信息包的报头信息，根据应用区间识别业务流，将整个区间段的业务流分配到合适的应用服务器进行处理。　第四层交换功能就象是虚IP，指向物理服务器。它传输的业务服从的协议多种多样，有HTTP、FTP、NFS、Telnet或其他协议。这些业务在物理服务器基础上，需要复杂的载量平衡算法。在IP世界，业务类型由终端TCP或UDP端口地址来决定，在第四层交换中的应用区间则由源端和终端IP地址、TCP和UDP端口共同决定。 
在硬件四层交换产品领域，有一些知名的产品可以选择，比如Alteon、F5等，这些产品很昂贵，但是物有所值，能够提供非常优秀的性能和很灵活的管理能力。Yahoo中国当初接近2000台服务器使用了三四台Alteon就搞定了。

### 集群如何同步会话状态

[集群session一致性和同步问题](http://blog.csdn.net/kk936321732/article/details/45484121)

[基于ZooKeeper的分布式Session实现](http://blog.csdn.net/jacktan/article/details/6112806)

### 负载均衡的原理

[六大Web负载均衡原理与实现](http://blog.csdn.net/asqi1/article/details/41478111)

### 如果有一个特别大的访问量，到数据库上，怎么做优化（DB设计，DBIO，SQL优化，Java优化）

[数据库SQL优化大总结之 百万级数据库优化方案](http://blog.csdn.net/zhushuai1221/article/details/51740846)

### 如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题

[如何提高服务器并发处理能力](https://www.cnblogs.com/zengjin93/p/5569556.html)

### 假如你的项目出现性能瓶颈了，你觉得可能会是哪些方面，怎么解决问题。

### 如何查找 造成 性能瓶颈出现的位置，是哪个位置照成性能瓶颈。

### 你的项目中使用过缓存机制吗？有没用用户非本地缓存



## Java内存模型
## 设计模式

### 单例模式：饱汉、饿汉。以及饿汉中的延迟加载,双重检查

### 工厂模式、装饰者模式、观察者模式。

### 工厂方法模式的优点（低耦合、高内聚，开放封闭原则）

### 如何理解观察者模式？
### 列举出你说熟悉的设计模式，并对其中的一种的使用举一个例子。

## JVM

### User user = new User()  做了什么操作，申请了哪些内存？

1. new User();  创建一个User对象，内存分配在堆上
2. User user;   创建一个引用，内存分配在栈上
3. =            将User对象地址赋值给引用

### Java的内存模型以及GC算法

[JVM内存模型与GC算法](https://www.cnblogs.com/kingszelda/p/7226080.html)

### jvm性能调优都做了什么

[JVM性能调优](http://uule.iteye.com/blog/2114697)

### 介绍JVM中7个区域，然后把每个区域可能造成内存的溢出的情况说明

### 介绍GC 和GC Root不正常引用

### 自己从classload 加载方式，加载机制说开去，从程序运行时数据区，讲到内存分配，讲到String常量池，讲到JVM垃圾回收机制，算法，hotspot。反正就是各种扩展

[java classload 机制 详解](http://blog.csdn.net/kiss_the_sun/article/details/50895503)

### jvm 如何分配直接内存， new 对象如何不分配在堆而是栈上，常量池解析

[JVM直接内存](http://blog.csdn.net/leaf_0303/article/details/78961936)

[浅谈HotSpot逃逸分析](https://www.jianshu.com/p/20bd2e9b1f03)

[触摸java常量池](http://www.cnblogs.com/iyangyuan/p/4631696.html)

### 数组多大放在 JVM 老年代（不只是设置 PretenureSizeThreshold ，问通常多大，没做过一问便知）

### 老年代中数组的访问方式

### GC 算法，永久代对象如何 GC ， GC 有环怎么处理

### 谁会被 GC ，什么时候 GC

### 如果想不被 GC 怎么办

### 如果想在 GC 中生存 1 次怎么办

### 分析System.gc()方法

### JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？

当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从 32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU 缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM 主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过 -XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。

### 写代码分别使得JVM的堆、栈和持久代发生内存溢出(栈溢出)

## 开源框架

### hibernate和ibatis的区别

### 讲讲mybatis的连接池。

### spring框架中需要引用哪些jar包，以及这些jar包的用途

### springMVC的原理

### springMVC注解的意思

### spring中beanFactory和ApplicationContext的联系和区别

### spring注入的几种方式（循环注入）

### spring如何实现事物管理的

### springIOC

### spring AOP的原理

### hibernate中的1级和2级缓存的使用方式以及区别原理（Lazy-Load的理解）

### Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。


## 分布式

### CAP原理和BASE理论

### 分布式事务、分布式锁

### 分布式存储系统

## redis

### redis和memcache的区别；

### 用redis做过什么；

### redis是如何持久化的：rdb和aof；

### redis集群如何同步；

### redis的数据添加过程是怎样的：哈希槽；

### redis的淘汰策略有哪些；

### redis有哪些数据结构；

## zookeeper
### zookeeper是什么；

### zookeeper哪里用到；

### zookeeper的选主过程；

### zookeeper集群之间如何通讯；

### 你们的zookeeper的节点加密是用的什么方式；

### 分布式锁的实现过程；

## kafka

### 传递保证语义：

* At most once：消息可能会丢，但绝不会重复传递。
* At least once：消息绝不会丢，但可能会重复传递。
* Exactly once： 每条消息只会被传递一次。

### 生产者的“Exactly once”语义方案

当生产者向Kafka发送消息，且正常得到响应的时候，可以确保生产者不会产生重复的消息。但是，如果生产者发送消息后，遇到网络问题，无法获取响应，生产者就无法判断该消息是否成功提交给了Kafka。根据生产者的机制，我们知道，当出现异常时，会进行消息重传，这就可能出现“At least one”语义。为了实现“Exactly once”语义，这里提供两个可选方案：

* 每个分区只有一个生产者写入消息，当出现异常或超时的情况时，生产者就要查询此分区的最后一个消息，用来决定后续操作是消息重传还是继续发送。
* 为每个消息添加一个全局唯一主键，生产者不做其他特殊处理，按照之前分析方式进行重传，由消费者对消息进行去重，实现“Exactly once”语义。

如果业务数据产生消息可以找到合适的字段作为主键，或是有一个全局ID生成器，可以优先考虑选用第二种方案。


### 消费者的“Exactly once”语义方案

为了实现消费者的“Exactly once”语义，在这里提供一种方案，供读者参考：消费者将关闭自动提交offset的功能且不再手动提交offset，这样就不使用Offsets Topic这个内部Topic记录其offset，而是由消费者自己保存offset。这里利用事务的原子性来实现“Exactly once”语义，我们将offset和消息处理结果放在一个事务中，事务执行成功则认为此消息被消费，否则事务回滚需要重新消费。当出现消费者宕机重启或Rebalance操作时，消费者可以从关系型数据库中找到对应的offset，然后调用KafkaConsumer.seek()方法手动设置消费位置，从此offset处开始继续消费。



## dubbo
## TCP/IP
## 算法

### 使用随机算法产生一个数，要求把1-1000W之间这些数全部生成。（考察高效率，解决产生冲突的问题）

### 两个有序数组的合并排序

### 一个数组的倒序

### 计算一个正整数的正平方根

### 说白了就是常见的那些查找、排序算法以及各自的时间复杂度

### 二叉树的遍历算法

### DFS,BFS算法

### 比较重要的数据结构，如链表，队列，栈的基本理解及大致实现。

### 排序算法与时空复杂度（快排为什么不稳定，为什么你的项目还在用）

### 逆波兰计算器

### Hoffman 编码

### 查找树与红黑树

## 设计与思想

### 重构过代码没有？说说经验；

### 一千万的用户实时排名如何实现；

### 五万人并发抢票怎么实现；

### 有个每秒钟5k个请求，查询手机号所属地的笔试题(记得不完整，没列出)，如何设计算法?请求再多，比如5w，如何设计整个系统?

### 高并发情况下，我们系统是如何支撑大量的请求的

### 集群如何同步会话状态

### 负载均衡的原理

### 如果有一个特别大的访问量，到数据库上，怎么做优化（DB设计，DBIO，SQL优化，Java优化）
    
### 如果出现大面积并发，在不增加服务器的基础上，如何解决服务器响应不及时问题“。
    
### 假如你的项目出现性能瓶颈了，你觉得可能会是哪些方面，怎么解决问题。

### 如何查找 造成 性能瓶颈出现的位置，是哪个位置照成性能瓶颈。

### 你的项目中使用过缓存机制吗？有没用用户非本地缓存

## 网络通信
   
### http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么。

### socket通信，以及长连接，分包，连接异常断开的处理。

### socket通信模型的使用，AIO和NIO。

### socket框架netty的使用，以及NIO的实现原理，为什么是异步非阻塞。

### 同步和异步，阻塞和非阻塞。

### OSI七层模型，包括TCP,IP的一些基本知识

* OSI七层模型： 1.物理层,2.链路层,3.网络层,4.会话层,5.表示层,6,应用层.
* TCP/IP： 对应OSI中的应用层、表示层、会话层. 对应的网络协议如:(HTTP,FTP,SMTP,DNS)

###  http中，get post的区别

* get： 从服务器上获取数据，也就是所谓的查，仅仅是获取服务器资源，不进行修改。
* post: 向服务器提交数据，这就涉及到了数据的更新，也就是更改服务器的数据。
* 请求方式的区别: get 请求的数据会附加在URL之后,特定的浏览器和服务器对URL的长度有限制. post 更加安全数据不会暴漏在url上,而且长度没有限制.

### 说说http,tcp,udp之间关系和区别。

### 说说浏览器访问http://www.taobao.com，经历了怎样的过程。

### HTTP协议、 HTTPS协议，SSL协议及完整交互过程；

### tcp的拥塞，快回传，ip的报文丢弃

### https处理的一个过程，对称加密和非对称加密

### head各个特点和区别

## 数据库MySql
   
### MySql的存储引擎的不同
   
### 单个索引、联合索引、主键索引
   
### Mysql怎么分表，以及分表后如果想按条件分页查询怎么办(如果不是按分表字段来查询的话，几乎效率低下，无解)
   
### 分表之后想让一个id多个表是自增的，效率实现
   
### MySql的主从实时备份同步的配置，以及原理(从库读主库的binlog)，读写分离
   
### 索引的数据结构，B+树
   
### 事务的四个特性，以及各自的特点（原子、隔离）等等，项目怎么解决这些问题
   
### 数据库的锁：行锁，表锁；乐观锁，悲观锁
   
### 数据库事务的几种粒度；
   
### 关系型和非关系型数据库区别

* 关系型数据库：是指采用了关系模型(二维表格模型)来组织数据的数据库。
* 非关系型数据库：以键值对存储，且结构不固定.
----
参考链接：
[阿里面试回来，想和Java程序员谈一谈](http://www.jianshu.com/p/5681a1f0aad6)
